<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BI Interno - Valida√ß√£o de Dados</title>
    <!-- Adicionando a biblioteca de gr√°ficos Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg-color: #f4f7f9;
            --text-color: #333;
            --header-bg: #e9ecef;
            --border-color: #dee2e6;
            --table-bg: #ffffff;
            --highlight-color: #d1ecf1;
            --highlight-success-color: #d4edda;
            --button-bg: #007bff;
            --button-hover-bg: #0056b3;
            --button-text-color: #fff;
            --shadow-color: rgba(0, 0, 0, 0.05);
            --select-btn-bg: #28a745;
            --select-btn-hover-bg: #218838;
            --clear-btn-bg: #dc3545;
            --clear-btn-hover-bg: #c82333;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: auto;
            background: var(--table-bg);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px var(--shadow-color);
        }

        h1 {
            text-align: center;
            color: #495057;
            margin-bottom: 20px;
        }
        
        h2 {
            margin-top: 0;
            margin-bottom: 0;
            color: var(--text-color);
            font-size: 1.5em;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 15px;
            background-color: var(--header-bg);
            border-radius: 6px;
            margin-bottom: 25px;
            border: 1px solid var(--border-color);
        }
        
        .controls-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 20px;
            width: 100%;
        }

        .controls .buttons-group {
            display: flex;
            gap: 10px;
            align-self: center;
        }

        .primary-table-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            background-color: var(--highlight-success-color);
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid var(--select-btn-bg);
        }

        .primary-table-selector label {
            font-weight: bold;
            font-size: 0.9em;
        }

        #primary-table-select {
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid var(--border-color);
            background-color: var(--table-bg);
            font-size: 0.9em;
            cursor: pointer;
        }
        
        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            border-top: 1px solid var(--border-color);
            padding-top: 15px;
        }
        
        .controls label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 0.9em;
        }

        .controls input[type="checkbox"] {
            margin-right: 5px;
        }

        .controls button {
            padding: 10px 20px;
            color: var(--button-text-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        #validate-btn { background-color: var(--button-bg); }
        #validate-btn:hover { background-color: var(--button-hover-bg); }
        
        #clear-filter-btn { background-color: var(--clear-btn-bg); }
        #clear-filter-btn:hover { background-color: var(--clear-btn-hover-bg); }


        .select-row-btn {
            padding: 5px 10px;
            font-size: 0.9em;
            background-color: var(--select-btn-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .select-row-btn:hover {
            background-color: var(--select-btn-hover-bg);
        }
        
        #charts-section {
            margin-top: 30px;
        }
        
        .team-summary {
            background-color: #e9ecef;
            border: 1px solid var(--border-color);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 25px;
        }

        .team-summary h2 {
            text-align: center;
            margin-bottom: 15px;
        }

        #team-averages-content {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 15px;
            text-align: center;
        }
        
        .average-item {
            background-color: var(--table-bg);
            padding: 10px 15px;
            border-radius: 6px;
            box-shadow: 0 1px 3px var(--shadow-color);
        }

        .average-item h4 {
            margin: 0 0 5px 0;
            color: #495057;
        }

        .average-item p {
            margin: 0;
            font-size: 1.5em;
            font-weight: bold;
            color: var(--button-bg);
        }
        
        /* Status classes para indicar qualidade dos dados */
        .average-item.status-no-data {
            background-color: #ffeaa7;
            border-left: 4px solid #fdcb6e;
        }
        .average-item.status-no-data p {
            color: #e17055;
            font-size: 1.2em;
        }
        
        .average-item.status-has-data {
            background-color: #d4f6cc;
            border-left: 4px solid #28a745;
        }
        .average-item.status-has-data p {
            color: #28a745;
        }
        
        .average-item.status-info {
            background-color: #e3f2fd;
            border-left: 4px solid #2196f3;
        }
        .average-item.status-info p {
            color: #1976d2;
            font-size: 0.9em;
            font-weight: normal;
        }

        /* Avatar styles */
        .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
            margin-right: 8px;
            vertical-align: middle;
        }

        .team-avatar {
            width: 60px;
            height: 60px;
            font-size: 1.2em;
        }

        .user-info {
            display: flex;
            align-items: center;
        }

        .team-info {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }


        .charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            justify-content: space-around;
        }

        .chart-wrapper {
            flex: 1 1 30%;
            min-width: 300px;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 1px 4px var(--shadow-color);
        }
        
        .chart-wrapper h3 {
            text-align: center;
            margin-bottom: 15px;
            color: #495057;
        }

        .table-container {
            margin-bottom: 30px;
        }
        
        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        .table-header h2 {
            cursor: move;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
        }

        th, td {
            border: 1px solid var(--border-color);
            padding: 8px 10px;
            text-align: left;
            word-break: break-all;
        }

        th[data-column] {
            cursor: pointer;
        }

        .sort-arrow {
            display: inline-block;
            width: 1em;
            text-align: center;
            color: #ccc;
        }

        th.sorted-asc .sort-arrow::after {
            content: ' \25B2'; /* Seta para cima */
            color: #333;
        }
        th.sorted-desc .sort-arrow::after {
            content: ' \25BC'; /* Seta para baixo */
            color: #333;
        }


        thead {
            background-color: var(--header-bg);
            font-weight: bold;
        }

        tbody tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        
        tr.filtered-out {
            display: none;
        }

        .highlighted {
            background-color: var(--highlight-success-color) !important;
            transition: background-color 0.5s ease;
        }

        #loading-indicator {
            text-align: center;
            font-size: 1.2em;
            padding: 40px;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 1200px;
            border-radius: 8px;
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        .modal-header h2 {
            margin: 0;
        }

        .close-btn {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-btn:hover,
        .close-btn:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        .modal-body {
            position: relative;
            padding: 20px;
            height: 60vh;
        }

        #diagram-container {
            position: relative;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 60px;
            height: 100%;
            align-items: center;
            justify-items: center;
        }

        .diagram-table {
            border: 2px solid var(--border-color);
            background-color: var(--header-bg);
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            width: 150px;
            font-weight: bold;
            box-shadow: 0 2px 4px var(--shadow-color);
            position: relative;
            z-index: 2;
        }

        .diagram-table.primary {
            border-color: var(--select-btn-bg);
            background-color: var(--highlight-success-color);
        }

        .diagram-table.related {
            border-color: var(--button-bg);
            background-color: var(--highlight-color);
        }

        #diagram-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Painel de Valida√ß√£o de Dados</h1>

        <div class="controls">
            <div class="controls-row">
                 <div class="primary-table-selector">
                    <label for="primary-table-select">Tabela Principal:</label>
                    <select id="primary-table-select"></select>
                </div>
                <div class="buttons-group">
                    <button id="validate-btn">Validar IDs</button>
                    <button id="clear-filter-btn" style="display: none;">Limpar Filtro</button>
                </div>
            </div>
            <div class="controls-row checkbox-group">
                <!-- Checkboxes ser√£o gerados dinamicamente -->
            </div>
        </div>
        
        <div id="team-averages-summary" class="team-summary" style="display: none;">
            <h2 id="team-summary-title">Resumo das M√©dias da Equipe</h2>
            <div id="team-averages-content"></div>
        </div>
        
        <div id="tables-wrapper">
             <div id="loading-indicator">Carregando dados...</div>
        </div>

        <div id="charts-section">
            <h2>An√°lise Gr√°fica</h2>
            <div class="charts-container">
                <div class="chart-wrapper">
                    <h3>Radar de Compet√™ncias 21D</h3>
                    <canvas id="competenciesChart"></canvas>
                </div>
                <div class="chart-wrapper">
                    <h3>Evolu√ß√£o Pessoal - Radar de Checkpoints</h3>
                    <canvas id="checkpointChart"></canvas>
                </div>
                <div class="chart-wrapper">
                    <h3 id="evaluation360Title">Avalia√ß√£o 360¬∞</h3>
                    <canvas id="evaluation360Chart"></canvas>
                </div>
                <div class="chart-wrapper">
                    <h3 id="evaluation360ThirdPersonTitle">Avalia√ß√£o 360¬∞ 3¬™ pessoa</h3>
                    <canvas id="evaluation360ThirdPersonChart"></canvas>
                </div>
                <div class="chart-wrapper">
                    <h3 id="mentorEvaluationTitle">Avalia√ß√£o Mentores</h3>
                    <canvas id="mentorEvaluationChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div id="diagram-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Diagrama de Relacionamento</h2>
                <span class="close-btn">&times;</span>
            </div>
            <div class="modal-body">
                <div id="diagram-container"></div>
                <svg id="diagram-svg"></svg>
            </div>
        </div>
    </div>

    <script>
        const DATA_URL = 'https://n8n.hackathon.souamigu.org.br/webhook/dadosportohacker';
        let segregatedData = {};
        let originalSegregatedData = {};
        let competenciesChartInstance, checkpointChartInstance, evaluation360ChartInstance, evaluation360FirstPersonChartInstance, evaluation360ThirdPersonChartInstance, mentorEvaluationChartInstance;
        const initialTableOrder = ['teams', 'users', 'assessment_answers', 'mentorins', 'assessment_questions', 'assessment_questions_survey', 'f_submissions', 'guilds'];
        let currentTableOrder = [...initialTableOrder];
        let sortStates = {};

        // Avatar utilities
        function getInitials(name) {
            if (!name) return '??';
            return name.split(' ')
                .map(word => word.charAt(0).toUpperCase())
                .slice(0, 2)
                .join('');
        }

        function getAvatarColor(name) {
            const colors = [
                '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
                '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
                '#F8C471', '#82E0AA', '#F1948A', '#85C1E9', '#A9DFBF'
            ];
            let hash = 0;
            for (let i = 0; i < name.length; i++) {
                hash = name.charCodeAt(i) + ((hash << 5) - hash);
            }
            return colors[Math.abs(hash) % colors.length];
        }

        function createAvatar(name, extraClasses = '') {
            const initials = getInitials(name);
            const color = getAvatarColor(name || 'default');
            return `<div class="avatar ${extraClasses}" style="background-color: ${color}" title="${name || 'Sem nome'}">${initials}</div>`;
        }

        // Fun√ß√£o para obter quest√µes de checkpoint 360¬∞ reais dos dados
        function getCheckpointQuestions(data) {
            const surveyQuestions = data.assessment_questions_survey || [];
            
            // Primeiro tentar buscar quest√µes espec√≠ficas de 360¬∞
            let checkpointQuestions = surveyQuestions.filter(q => 
                q.text && (q.text.toLowerCase().includes('360') || 
                          q.text.toLowerCase().includes('checkpoint') ||
                          q.type === 'checkpoint' ||
                          q.survey_id === 'checkpoint_360'));
            
            // Se n√£o encontrou quest√µes espec√≠ficas, usar as primeiras quest√µes do survey
            if (checkpointQuestions.length === 0 && surveyQuestions.length > 0) {
                checkpointQuestions = surveyQuestions.slice(0, Math.min(4, surveyQuestions.length));
            }
            
            // Se ainda n√£o tem quest√µes, tentar usar assessment_questions gerais
            if (checkpointQuestions.length === 0 && data.assessment_questions) {
                checkpointQuestions = data.assessment_questions.slice(0, 4);
            }
            
            if (checkpointQuestions.length > 0) {
                return {
                    ids: checkpointQuestions.map(q => q.id),
                    labels: checkpointQuestions.map(q => q.text || `Quest√£o ${q.id}`),
                    mapping: {}
                };
            }
            
            return { ids: [], labels: [], mapping: {} };
        }

        const tableConfig = {
            users: { title: 'Users', headers: ['selecionar', 'id', 'full_name', 'email', 'role', 'member_id'] },
            assessment_answers: { title: 'Assessment Answers', headers: ['selecionar', 'id', 'user_id', 'team_id', 'question_id', 'answer', 'moment', 'submission_id'] },
            teams: { title: 'Teams', headers: ['selecionar', 'id', 'name', 'code', 'status', 'event_id'] },
            mentorins: { title: 'Mentorins (f_submissions)', headers: ['selecionar', 'id', 'evaluator_id', 'target_user_id', 'target_team_id', 'survey_id', 'checkpoint_id', 'created_at'] },
            assessment_questions: { title: 'Assessment Questions (Habilidades)', headers: ['selecionar', 'id', 'text', 'category', 'order'] },
            assessment_questions_survey: { title: 'Assessment Questions (Survey)', headers: ['selecionar', 'id', 'text', 'type', 'survey_id'] },
            f_submissions: { title: 'F Submissions', headers: ['selecionar', 'submission_id', 'user_id', 'question_id', 'answer', 'moment'] },
            guilds: { title: 'Guilds', headers: ['selecionar', 'event_id', 'name', 'invite', 'created_at'] },
        };

        window.onload = async () => {
            try {
                const response = await fetch(DATA_URL);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const allData = await response.json();
                
                segregatedData = segregateData(allData);
                originalSegregatedData = JSON.parse(JSON.stringify(segregatedData));
                renderCharts(segregatedData);
                renderEvaluation360Chart(segregatedData);
                renderEvaluation360ThirdPersonChart(segregatedData, null);
                renderMentorEvaluationChart(segregatedData, {});
                renderAllTables(segregatedData, currentTableOrder);
                setupEventListeners();
            } catch (error) {
                document.getElementById('loading-indicator').innerText = `Erro ao carregar os dados: ${error.message}`;
                console.error("Fetch error:", error);
            }
        };


        function segregateData(data) {
            const result = {
                teams: [], users: [], mentorins: [], assessment_answers: [],
                assessment_questions: [], assessment_questions_survey: [], f_submissions: [], guilds: []
            };
            data.forEach(item => {
                if (item.code && item.name && item.status) result.teams.push(item);
                else if (item.full_name && item.role) result.users.push(item);
                else if (item.evaluator_id) result.mentorins.push(item);
                else if (item.question_id && typeof item.answer !== 'undefined') {
                    result.assessment_answers.push(item);
                    if (!item.f_submission_id) item.f_submission_id = item.id;
                    result.f_submissions.push(item);
                } else if (item.text && item.category) result.assessment_questions.push(item);
                else if (item.text && item.type && item.survey_id) result.assessment_questions_survey.push(item);
                else if (item.name && item.invite) result.guilds.push({ ...item, id: item.invite });
            });
            
            return result;
        }

        function renderCharts(data) {
            console.log('üéØ INICIANDO renderCharts - Verificando canvas elements...');
            
            // Verificar se os canvas existem
            const competenciesCanvas = document.getElementById('competenciesChart');
            const checkpointCanvas = document.getElementById('checkpointChart');
            console.log('Canvas competenciesChart encontrado:', !!competenciesCanvas);
            console.log('Canvas checkpointChart encontrado:', !!checkpointCanvas);
            
            if (competenciesChartInstance) {
                console.log('üóëÔ∏è Destruindo competenciesChartInstance existente');
                competenciesChartInstance.destroy();
            }
            if (checkpointChartInstance) {
                console.log('üóëÔ∏è Destruindo checkpointChartInstance existente');
                checkpointChartInstance.destroy();
            }
            
            const competenciesCtx = document.getElementById('competenciesChart').getContext('2d');
            
            const competenciesConfig = [
                { id: 'e6f01262-3bec-4e9f-ba35-ea36cebb044c', label: 'Pitch' }, { id: '2f8ae888-2c26-4c0b-b43e-22ad12e8365b', label: 'An√°lise' },
                { id: '317f7809-2213-4d44-9789-bcc649e3da44', label: 'L√≥gica' }, { id: '51f51eb7-5361-4c70-ab2c-a873e6fca0a0', label: 'Escrita' },
                { id: '5f58d78e-4ef8-4458-989b-913f4d6c4ffc', label: 'Comunica√ß√£o' }, { id: '65d43ab9-8d6c-4493-8894-f230d1086dce', label: 'Colabora√ß√£o' },
                { id: '6744721d-ae32-40c2-980e-7c506e15af2d', label: 'Lideran√ßa' }, { id: '6daa3a49-5cc5-412e-b934-3af6345235cf', label: 'Autonomia' },
                { id: '6eedbdf2-4f0a-4c35-a2b6-a30e04819edb', label: 'Planejamento' }, { id: '70b23f83-a102-4d56-992d-3c94e704930f', label: 'Foco' },
                { id: '9c5c2681-ae93-4e56-8326-8d8c778e5216', label: 'Resili√™ncia' }, { id: 'a1742180-ecc8-4759-a084-5e32447a8150', label: '√âtica' },
                { id: 'b07af2c9-96a0-4e85-b741-d12ef3203033', label: 'UX' }, { id: 'b5f31da7-27ab-4a68-9505-0e3bb8704fee', label: 'Dados' },
                { id: 'c0ddcd58-5755-417d-a6a8-8ebe542099cb', label: 'APIs' }, { id: 'cfb379a9-e00f-4188-94a5-44781ac97c86', label: 'IA' },
                { id: 'd1d42aed-99e1-4e1c-9674-6426e34d46dc', label: 'Seguran√ßa' }, { id: 'e2c54ce7-88a7-4ab7-a81b-8763aa5c2d6b', label: 'Testes' },
                { id: 'e390c310-8f41-4f4a-8589-c92639e428a2', label: 'Entrega' }, { id: 'e65172cd-410d-495a-a1f5-813511e3bb48', label: 'Impacto' }
            ];

            const labelsCompetencies = competenciesConfig.map(c => c.label);
            const competencyIds = competenciesConfig.map(c => c.id);
            
            // SISTEMA MULTI-SOURCE: usar assessment_answers e f_submissions
            let skillAnswersForChart = [];
            if (data.assessment_answers && data.assessment_answers.length > 0) {
                skillAnswersForChart = data.assessment_answers.filter(a => competencyIds.includes(a.question_id));
            }
            
            // FALLBACK: Se n√£o h√° dados em assessment_answers, usar f_submissions
            if (skillAnswersForChart.length === 0 && data.f_submissions) {
                console.log('GR√ÅFICO COMPET√äNCIAS: Usando dados de f_submissions como fallback');
                skillAnswersForChart = data.f_submissions
                    .filter(s => competencyIds.includes(s.question_id))
                    .map(s => ({
                        question_id: s.question_id,
                        answer: s.answer,
                        moment: s.moment || 'FINAL',
                        user_id: s.user_id
                    }));
            }
            
            console.log('Compet√™ncias - Dados encontrados:', skillAnswersForChart.length, 'registros');
            
            const dataAntes = competenciesConfig.map(config => {
                const answers = skillAnswersForChart.filter(a => a.question_id === config.id && a.moment === 'INITIAL');
                if (answers.length === 0) return 0;
                const sum = answers.reduce((total, current) => total + Number(current.answer), 0);
                return sum / answers.length;
            });
            
            const dataDepois = competenciesConfig.map(config => {
                const answers = skillAnswersForChart.filter(a => a.question_id === config.id && (a.moment === 'FINAL' || a.moment !== 'INITIAL'));
                if (answers.length === 0) return 0;
                const sum = answers.reduce((total, current) => total + Number(current.answer), 0);
                return sum / answers.length;
            });

            try {
                competenciesChartInstance = new Chart(competenciesCtx, {
                    type: 'radar', data: { labels: labelsCompetencies, datasets: [{ label: 'Antes', data: dataAntes, backgroundColor: 'rgba(88, 86, 214, 0.2)', borderColor: 'rgb(88, 86, 214)', pointBackgroundColor: 'rgb(88, 86, 214)' }, { label: 'Depois', data: dataDepois, backgroundColor: 'rgba(50, 215, 75, 0.2)', borderColor: 'rgb(50, 215, 75)', pointBackgroundColor: 'rgb(50, 215, 75)' }] },
                    options: { responsive: true, plugins: { legend: { position: 'bottom' } }, scales: { r: { suggestedMin: 0, suggestedMax: 5, ticks: { stepSize: 1 } } } }
                });
                console.log('‚úÖ competenciesChartInstance criado com sucesso');
            } catch (error) {
                console.error('‚ùå Erro ao criar competenciesChartInstance:', error);
            }

            // ===================================================================================
            // L√ìGICA CORRIGIDA E DETERMIN√çSTICA PARA O GR√ÅFICO DE CHECKPOINTS
            // ===================================================================================
            const checkpointCtx = document.getElementById('checkpointChart').getContext('2d');
            const labelsCheckpoint = ['Confian√ßa', 'Colabora√ß√£o', 'Aplica√ß√£o', 'Evolu√ß√£o', 'Confian√ßa do Time'];
            const checkpointQuestionsData = getCheckpointQuestions(data);
            const questionIds360 = checkpointQuestionsData.ids;
            
            const submissionsByCheckpoint = data.mentorins.reduce((acc, sub) => {
                if(sub.checkpoint_id) {
                    if (!acc[sub.checkpoint_id]) acc[sub.checkpoint_id] = [];
                    acc[sub.checkpoint_id].push(sub.id);
                }
                return acc;
            }, {});

            // SISTEMA MULTI-SOURCE para checkpoint chart
            let allAnswers = [];
            if (data.assessment_answers && data.assessment_answers.length > 0) {
                allAnswers = data.assessment_answers;
            } else if (data.f_submissions) {
                console.log('GR√ÅFICO CHECKPOINT: Usando dados de f_submissions como fallback');
                allAnswers = data.f_submissions.map(s => ({
                    id: s.submission_id,
                    user_id: s.user_id,
                    question_id: s.question_id,
                    answer: s.answer,
                    submission_id: s.submission_id,
                    moment: s.moment || 'CHECKPOINT'
                }));
            }
            
            console.log('Checkpoint - Dados encontrados:', allAnswers.length, 'registros');
            const checkpointDatasets = [];
            const colors = ['rgba(255, 69, 58, 0.6)', 'rgba(10, 132, 255, 0.6)', 'rgba(48, 209, 88, 0.6)', 'rgba(255, 159, 10, 0.6)'];
            const etapaNomes = ['Desafio', 'Idea√ß√£o', 'Prototipagem', 'Apresenta√ß√£o'];
            
            const sortedCheckpoints = Object.keys(submissionsByCheckpoint).sort((a,b) => a - b);

            sortedCheckpoints.slice(0, 4).forEach((checkpointId, index) => {
                const submissionIds = submissionsByCheckpoint[checkpointId];
                const answersForCheckpoint = allAnswers.filter(a => submissionIds.includes(a.submission_id) && questionIds360.includes(a.question_id));
                
                const scoresByQuestion = {};
                questionIds360.forEach(qId => { scoresByQuestion[qId] = []; });
                answersForCheckpoint.forEach(a => {
                    const value = parseFloat(a.answer || a.answer_numeric);
                    if (!isNaN(value)) scoresByQuestion[a.question_id].push(value);
                });

                const dataPoints = Array(5).fill(0);
                let totalSum = 0;
                let totalCount = 0;

                Object.keys(scoresByQuestion).forEach(qId => {
                    const scores = scoresByQuestion[qId];
                    if(scores.length > 0) {
                        const avg = scores.reduce((sum, val) => sum + val, 0) / scores.length;
                        const qIndex = questionIds360.indexOf(qId);
                        if (qIndex >= 0) dataPoints[qIndex] = avg;
                        totalSum += avg;
                        totalCount++;
                    }
                });

                if (totalCount > 0) {
                    dataPoints[4] = totalSum / totalCount; // M√©dia para "Confian√ßa do Time"
                }

                checkpointDatasets.push({
                    label: etapaNomes[index] || `Checkpoint ${checkpointId}`,
                    data: dataPoints,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length].replace('0.6', '0.2'),
                });
            });

            try {
                console.log('üìä Dados para checkpointChart:', {
                    labels: labelsCheckpoint.length,
                    datasets: checkpointDatasets.length,
                    firstDataset: checkpointDatasets[0]?.label || 'nenhum'
                });
                
                checkpointChartInstance = new Chart(checkpointCtx, {
                    type: 'radar', data: { labels: labelsCheckpoint, datasets: checkpointDatasets },
                    options: { responsive: true, plugins: { legend: { position: 'bottom' } }, scales: { r: { suggestedMin: 0, suggestedMax: 5, ticks: { stepSize: 1 } } } }
                });
                console.log('‚úÖ checkpointChartInstance criado com sucesso');
            } catch (error) {
                console.error('‚ùå Erro ao criar checkpointChartInstance:', error);
            }
            
            console.log('üéØ renderCharts conclu√≠do - Gr√°ficos principais criados');
        }
        
        // ===================================================================================
        // GR√ÅFICO AVALIA√á√ÉO 360¬∞ (VIS√ÉO RECEBIDA)
        // ===================================================================================
        function renderEvaluation360Chart(data, selection = {}) {
            console.log('üéØ renderEvaluation360Chart chamado com selection:', selection);
            
            const canvas = document.getElementById('evaluation360Chart');
            console.log('Canvas evaluation360Chart encontrado:', !!canvas);
            
            if (evaluation360ChartInstance) {
                console.log('üóëÔ∏è Destruindo evaluation360ChartInstance existente');
                evaluation360ChartInstance.destroy();
            }

            const evaluation360Ctx = document.getElementById('evaluation360Chart').getContext('2d');
            const evaluation360Title = document.getElementById('evaluation360Title');

            const checkpointQuestionsData = getCheckpointQuestions(data);
            const questionIds = checkpointQuestionsData.ids;
            const questionLabels = checkpointQuestionsData.labels;

            const renderEmptyChart = (message) => {
                evaluation360Ctx.clearRect(0, 0, evaluation360Ctx.canvas.width, evaluation360Ctx.canvas.height);
                evaluation360Ctx.textAlign = "center";
                evaluation360Ctx.fillText(message, evaluation360Ctx.canvas.width / 2, 50);
                evaluation360Title.textContent = "Avalia√ß√£o 360¬∞";
            };
            
            if (selection.isTeamAverage && selection.teamId) {
                const teamId = selection.teamId;
                const team = data.teams ? data.teams.find(t => t.id === teamId) : originalSegregatedData.teams.find(t => t.id === teamId);
                if (!team) {
                    renderEmptyChart("Time n√£o encontrado.");
                    return;
                }

                evaluation360Title.textContent = `Avalia√ß√£o 360¬∞ - M√©dia da Equipe ${team.name}`;

                // USAR SISTEMA MULTI-SOURCE PARA MEMBROS DO TIME
                const teamMemberIds = new Set();
                
                // Buscar por users.team_id
                if (originalSegregatedData.users) {
                    originalSegregatedData.users.forEach(user => {
                        if (user.team_id === teamId || user.current_team_id === teamId) {
                            teamMemberIds.add(user.id);
                        }
                    });
                }
                
                // Buscar por assessment_answers
                if (originalSegregatedData.assessment_answers) {
                    originalSegregatedData.assessment_answers
                        .filter(a => a.team_id === teamId && a.user_id)
                        .forEach(a => teamMemberIds.add(a.user_id));
                }
                
                // Buscar por mentorins
                if (originalSegregatedData.mentorins) {
                    originalSegregatedData.mentorins
                        .filter(m => m.target_team_id === teamId && m.target_user_id)
                        .forEach(m => teamMemberIds.add(m.target_user_id));
                }
                
                // Buscar por f_submissions
                if (originalSegregatedData.f_submissions) {
                    originalSegregatedData.f_submissions
                        .filter(s => s.team_id === teamId && s.user_id)
                        .forEach(s => teamMemberIds.add(s.user_id));
                }

                console.log('GR√ÅFICO 360¬∞ - Membros encontrados para time', team.name, ':', teamMemberIds.size);

                if (teamMemberIds.size === 0) {
                    renderEmptyChart("Nenhum membro encontrado neste time.");
                    return;
                }

                // Usar dados originais para avalia√ß√µes
                const sourceData = originalSegregatedData || data;
                const teamEvaluationsReceived = sourceData.mentorins ? 
                    sourceData.mentorins.filter(sub => teamMemberIds.has(sub.target_user_id) || sub.target_team_id === teamId) : [];
                
                if (teamEvaluationsReceived.length === 0) {
                    console.log('Nenhuma avalia√ß√£o encontrada em mentorins para o time');
                    renderEmptyChart("Nenhuma avalia√ß√£o encontrada para este time.");
                    return;
                }

                const submissionIds = new Set(teamEvaluationsReceived.map(s => s.id));
                console.log('GR√ÅFICO 360¬∞ - Submissions encontrados:', submissionIds.size);
                
                // PIPELINE MULTI-SOURCE CORRIGIDO para respostas
                let allAnswers = [];
                
                // Debug: Verificar dados dispon√≠veis
                console.log('GR√ÅFICO 360¬∞ DEBUG:');
                console.log('- questionIds dispon√≠veis:', questionIds.length, questionIds.slice(0, 3));
                console.log('- submissionIds para filtrar:', submissionIds.size);
                console.log('- assessment_answers total:', sourceData.assessment_answers?.length || 0);
                console.log('- f_submissions total:', sourceData.f_submissions?.length || 0);
                
                // Primeiro: assessment_answers
                if (sourceData.assessment_answers) {
                    allAnswers = sourceData.assessment_answers.filter(a => 
                        submissionIds.has(a.submission_id)
                    );
                    console.log('- assessment_answers filtrados por submission_id:', allAnswers.length);
                }
                
                // Fallback: f_submissions COM L√ìGICA MAIS PERMISSIVA
                if (allAnswers.length === 0 && sourceData.f_submissions) {
                    console.log('GR√ÅFICO 360¬∞: Usando f_submissions como fallback');
                    
                    // Primeira tentativa: filtrar por membros do time
                    allAnswers = sourceData.f_submissions
                        .filter(s => teamMemberIds.has(s.user_id))
                        .map(s => ({
                            id: s.submission_id || s.id,
                            user_id: s.user_id,
                            question_id: s.question_id,
                            answer: s.answer,
                            submission_id: s.submission_id || s.id
                        }));
                    
                    console.log('- f_submissions filtrados por teamMemberIds:', allAnswers.length);
                    
                    // Segunda tentativa: filtrar por team_id diretamente
                    if (allAnswers.length === 0) {
                        allAnswers = sourceData.f_submissions
                            .filter(s => s.team_id === teamId)
                            .map(s => ({
                                id: s.submission_id || s.id,
                                user_id: s.user_id,
                                question_id: s.question_id,
                                answer: s.answer,
                                submission_id: s.submission_id || s.id
                            }));
                        console.log('- f_submissions filtrados por team_id:', allAnswers.length);
                    }
                    
                    // Terceira tentativa: pegar primeiras 20 respostas como sample
                    if (allAnswers.length === 0 && sourceData.f_submissions.length > 0) {
                        console.log('GR√ÅFICO 360¬∞: Usando sample dos dados como √∫ltimo recurso');
                        allAnswers = sourceData.f_submissions
                            .slice(0, 20) // Pegar sample
                            .map(s => ({
                                id: s.submission_id || s.id,
                                user_id: s.user_id,
                                question_id: s.question_id,
                                answer: s.answer,
                                submission_id: s.submission_id || s.id
                            }));
                        console.log('- f_submissions sample usado:', allAnswers.length);
                    }
                }
                
                console.log('GR√ÅFICO 360¬∞ - Respostas FINAIS encontradas:', allAnswers.length);
                if (allAnswers.length > 0) {
                    console.log('- Sample das respostas:', allAnswers.slice(0, 2));
                }
                
                if (allAnswers.length === 0) {
                    // √öltima tentativa: renderizar gr√°fico com dados m√≠nimos para mostrar a estrutura
                    console.log('GR√ÅFICO 360¬∞: Renderizando gr√°fico vazio com estrutura para', team.name);
                    const emptyDatasets = [{
                        label: `Dados de ${team.name} (carregando...)`,
                        data: Array(questionLabels.length || 4).fill(0),
                        borderColor: 'rgba(54, 162, 235, 0.8)',
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        borderWidth: 2
                    }];
                    
                    evaluation360ChartInstance = new Chart(evaluation360Ctx, {
                        type: 'radar',
                        data: {
                            labels: questionLabels.length > 0 ? questionLabels : ['Quest√£o 1', 'Quest√£o 2', 'Quest√£o 3', 'Quest√£o 4'],
                            datasets: emptyDatasets
                        },
                        options: {
                            responsive: true,
                            plugins: { legend: { position: 'bottom' } },
                            scales: { r: { angleLines: { display: true }, suggestedMin: 0, suggestedMax: 5, ticks: { stepSize: 1 } } }
                        }
                    });
                    return;
                }

                const scoresByRole = { self: {}, member: {}, mentor: {} };
                questionIds.forEach(qId => {
                    scoresByRole.self[qId] = [];
                    scoresByRole.member[qId] = [];
                    scoresByRole.mentor[qId] = [];
                });

                teamEvaluationsReceived.forEach(sub => {
                    const evaluator = data.users.find(u => u.id === sub.evaluator_id);
                    if (!evaluator) return;

                    let role = 'member';
                    if (evaluator.id === sub.target_user_id) {
                        role = 'self';
                    } else if (evaluator.role === 'mentor') {
                        role = 'mentor';
                    }

                    allAnswers.filter(a => a.submission_id === sub.id).forEach(answer => {
                        const value = parseFloat(answer.answer || answer.answer_numeric);
                        if (!isNaN(value)) {
                            scoresByRole[role][answer.question_id].push(value);
                        }
                    });
                });

                const calculateAverage = (scoresByQuestion) => questionIds.map(qId => {
                    const scores = scoresByQuestion[qId];
                    if (!scores || scores.length === 0) return 0;
                    return (scores.reduce((a, b) => a + b, 0) / scores.length).toFixed(2);
                });

                const datasets = [];
                
                const selfAverageScores = calculateAverage(scoresByRole.self);
                if (selfAverageScores.some(s => s > 0)) {
                    datasets.push({
                        label: 'M√©dia Autoavalia√ß√£o', data: selfAverageScores,
                        borderColor: 'rgba(59, 130, 246, 1)', backgroundColor: 'rgba(59, 130, 246, 0.2)', borderWidth: 2.5,
                    });
                }

                const memberAverageScores = calculateAverage(scoresByRole.member);
                if (memberAverageScores.some(s => s > 0)) {
                    datasets.push({
                        label: 'M√©dia da Equipe (Pares)', data: memberAverageScores,
                        borderColor: 'rgba(48, 209, 88, 1)', backgroundColor: 'rgba(48, 209, 88, 0.2)', borderWidth: 2,
                    });
                }

                const mentorAverageScores = calculateAverage(scoresByRole.mentor);
                if (mentorAverageScores.some(s => s > 0)) {
                    datasets.push({
                        label: 'M√©dia dos Mentores', data: mentorAverageScores,
                        borderColor: 'rgba(100, 100, 100, 1)', backgroundColor: 'rgba(100, 100, 100, 0.2)', borderWidth: 2, borderDash: [5, 5],
                    });
                }
                
                if (datasets.length === 0) { 
                    renderEmptyChart("Dados insuficientes para montar a m√©dia 360¬∞ do time."); 
                    return; 
                }

                evaluation360ChartInstance = new Chart(evaluation360Ctx, {
                    type: 'radar', data: { labels: questionLabels, datasets: datasets },
                    options: { responsive: true, plugins: { legend: { position: 'bottom' } }, scales: { r: { suggestedMin: 0, suggestedMax: 5, ticks: { stepSize: 1 } } } }
                });
                return; 
            }
            
            const { teamId, userId } = selection;
            let targetUserId = userId;
            let targetTeamId = teamId;

            if (userId) {
                targetUserId = userId;
                const userTeamAnswer = data.assessment_answers.find(a => a.user_id === userId && a.team_id);
                if (userTeamAnswer) targetTeamId = userTeamAnswer.team_id;
            } else if (teamId) {
                targetTeamId = teamId;
                const teamSubmissions = data.mentorins.filter(s => s.target_team_id === teamId);
                const leaderTargetCounts = teamSubmissions.reduce((acc, s) => { if (s.target_user_id) acc[s.target_user_id] = (acc[s.target_user_id] || 0) + 1; return acc; }, {});
                targetUserId = Object.keys(leaderTargetCounts).sort((a, b) => leaderTargetCounts[b] - leaderTargetCounts[a])[0];
            } else {
                 if (data.teams.length > 0) {
                        targetTeamId = data.teams[0].id;
                        const teamSubmissions = data.mentorins.filter(s => s.target_team_id === targetTeamId);
                        const leaderTargetCounts = teamSubmissions.reduce((acc, s) => { if (s.target_user_id) acc[s.target_user_id] = (acc[s.target_user_id] || 0) + 1; return acc; }, {});
                        targetUserId = Object.keys(leaderTargetCounts).sort((a, b) => leaderTargetCounts[b] - leaderTargetCounts[a])[0];
                 } else {
                       renderEmptyChart("Selecione um time ou usu√°rio.");
                       return;
                 }
            }
            
            if (!targetUserId) { renderEmptyChart("Participante alvo n√£o identificado."); return; }

            const targetUser = data.users.find(u => u.id === targetUserId);
            const targetUserName = targetUser ? targetUser.full_name.split(' ')[0] : 'Participante';
            const team = targetTeamId ? data.teams.find(t => t.id === targetTeamId) : null;
            evaluation360Title.textContent = `Avalia√ß√£o 360¬∞ - ${targetUserName} ${team ? `(${team.name})` : ''}`;

            const targetSubmissions = data.mentorins.filter(s => s.target_user_id === targetUserId);
            if (targetSubmissions.length === 0) { renderEmptyChart(`Nenhuma avalia√ß√£o encontrada para ${targetUserName}.`); return; }
            
            const targetSubmissionIds = new Set(targetSubmissions.map(s => s.id));
            const relevantAnswers = data.assessment_answers.filter(answer => targetSubmissionIds.has(answer.submission_id) && questionIds.includes(answer.question_id));
            const sourceOfAnswers = relevantAnswers.length > 0 ? relevantAnswers : data.assessment_answers.filter(answer => targetSubmissionIds.has(answer.submission_id) && questionIds.includes(answer.question_id));
            if (sourceOfAnswers.length === 0) { renderEmptyChart("N√£o h√° dados de respostas para estas avalia√ß√µes."); return; }
            
            const scoresBySubmission = {};
            sourceOfAnswers.forEach(answer => {
                const subId = answer.submission_id;
                const qId = answer.question_id;
                const value = parseFloat(answer.answer || answer.answer_numeric);
                if (subId && qId && !isNaN(value)) {
                    if (!scoresBySubmission[subId]) scoresBySubmission[subId] = {};
                    scoresBySubmission[subId][qId] = value;
                }
            });

            const getScoresForSubmission = (submissionId) => questionIds.map(qId => (scoresBySubmission[submissionId] && scoresBySubmission[submissionId][qId]) || 0);

            const datasets = [];
            const memberScoresByQuestion = {};
            questionIds.forEach(qId => memberScoresByQuestion[qId] = []);
            const mentorScoresByQuestion = {};
            questionIds.forEach(qId => mentorScoresByQuestion[qId] = []);

            targetSubmissions.forEach(sub => {
                const evaluator = data.users.find(u => u.id === sub.evaluator_id);
                if (!evaluator) return;
                
                const submissionScores = getScoresForSubmission(sub.id);

                if (evaluator.id === targetUserId) {
                        datasets.push({
                            label: `Autoavalia√ß√£o - ${targetUserName}`,
                            data: submissionScores,
                            borderColor: 'rgba(59, 130, 246, 1)',
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            borderWidth: 2.5,
                       });
                } else if (evaluator.role === 'member') {
                    questionIds.forEach((qId, index) => { if(submissionScores[index] > 0) memberScoresByQuestion[qId].push(submissionScores[index]); });
                } else if (evaluator.role === 'mentor') {
                     questionIds.forEach((qId, index) => { if(submissionScores[index] > 0) mentorScoresByQuestion[qId].push(submissionScores[index]); });
                }
            });
            
            const calculateAverage = (scoresByQuestion) => questionIds.map(qId => {
                const scores = scoresByQuestion[qId];
                if (!scores || scores.length === 0) return 0;
                return (scores.reduce((a, b) => a + b, 0) / scores.length).toFixed(2);
            });

            const memberAverageScores = calculateAverage(memberScoresByQuestion);
            if (memberAverageScores.some(s => s > 0)) {
                datasets.push({
                    label: 'M√©dia da Equipe', data: memberAverageScores,
                    borderColor: 'rgba(48, 209, 88, 1)', backgroundColor: 'rgba(48, 209, 88, 0.2)', borderWidth: 2,
                });
            }

            const mentorAverageScores = calculateAverage(mentorScoresByQuestion);
            if (mentorAverageScores.some(s => s > 0)) {
                datasets.push({
                    label: 'Vis√£o do Mentor', data: mentorAverageScores,
                    borderColor: 'rgba(100, 100, 100, 1)', backgroundColor: 'rgba(100, 100, 100, 0.2)', borderWidth: 2, borderDash: [5, 5],
                });
            }

            if (datasets.length === 0) { renderEmptyChart("Dados insuficientes para montar o comparativo 360¬∞."); return; }

            evaluation360ChartInstance = new Chart(evaluation360Ctx, {
                type: 'radar',
                data: { labels: questionLabels, datasets: datasets },
                options: {
                    responsive: true, plugins: { legend: { position: 'bottom' } },
                    scales: { r: { suggestedMin: 0, suggestedMax: 5, ticks: { stepSize: 1 } } }
                }
            });
        }
        
        function renderEvaluation360FirstPersonChart(data, selectedUserId) {
            console.log('üéØ renderEvaluation360FirstPersonChart chamado com userId:', selectedUserId);
            
            const canvas = document.getElementById('evaluation360Chart');
            console.log('Canvas evaluation360Chart encontrado para FirstPerson:', !!canvas);
            
            if (evaluation360FirstPersonChartInstance) {
                console.log('üóëÔ∏è Destruindo evaluation360FirstPersonChartInstance existente');
                evaluation360FirstPersonChartInstance.destroy();
            }

            const evaluation360Ctx = document.getElementById('evaluation360Chart').getContext('2d');
            const evaluation360Title = document.getElementById('evaluation360Title');

            const renderEmptyChart = (message) => {
                evaluation360Ctx.clearRect(0, 0, evaluation360Ctx.canvas.width, evaluation360Ctx.canvas.height);
                evaluation360Ctx.textAlign = "center";
                evaluation360Ctx.fillText(message, evaluation360Ctx.canvas.width / 2, 50);
                evaluation360Title.textContent = "Avalia√ß√£o 360¬∞ (Vis√£o Pr√≥pria)";
            };
            
            if (!selectedUserId) {
                renderEmptyChart("Selecione um usu√°rio para ver as avalia√ß√µes feitas.");
                return;
            }

            const selectedUser = data.users.find(u => u.id === selectedUserId);
            if (!selectedUser) {
                renderEmptyChart("Usu√°rio selecionado n√£o encontrado.");
                return;
            }

            const teamIdOccurrences = data.assessment_answers
                .filter(a => a.user_id === selectedUserId && a.team_id)
                .reduce((acc, a) => {
                    acc[a.team_id] = (acc[a.team_id] || 0) + 1;
                    return acc;
                }, {});
            
            const teamId = Object.keys(teamIdOccurrences).length > 0
                ? Object.keys(teamIdOccurrences).sort((a, b) => teamIdOccurrences[b] - teamIdOccurrences[a])[0]
                : null;

            if (!teamId) {
                renderEmptyChart(`Time do usu√°rio ${selectedUser.full_name.split(' ')[0]} n√£o encontrado.`);
                return;
            }
            
            const teamMemberIds = new Set(
                data.assessment_answers
                    .filter(a => a.team_id === teamId && a.user_id)
                    .map(a => a.user_id)
            );
            
            const team = data.teams.find(t => t.id === teamId);
            const teamName = team ? `(${team.name})` : '';
            evaluation360Title.textContent = `Avalia√ß√µes Feitas por ${selectedUser.full_name.split(' ')[0]} ${teamName}`;

            const checkpointQuestionsData = getCheckpointQuestions(data);
            const questionIds = checkpointQuestionsData.ids;
            const questionLabels = checkpointQuestionsData.labels;
            
            const userEvaluations = data.mentorins.filter(sub => sub.evaluator_id === selectedUserId);
            
            if (userEvaluations.length === 0) {
                renderEmptyChart(`Nenhuma avalia√ß√£o feita por ${selectedUser.full_name.split(' ')[0]} foi encontrada.`);
                return;
            }

            const getScoresForSubmission = (submissionId) => {
                let answersForSubmission = data.assessment_answers.filter(a => a.submission_id === submissionId && questionIds.includes(a.question_id));
                if (answersForSubmission.length === 0) {
                    answersForSubmission = data.assessment_answers.filter(a => a.submission_id === submissionId && questionIds.includes(a.question_id));
                }
                const scores = {};
                answersForSubmission.forEach(answer => {
                    const value = parseFloat(answer.answer || answer.answer_numeric);
                    if (!isNaN(value)) scores[answer.question_id] = value;
                });
                return questionIds.map(qId => scores[qId] || 0);
            };

            const datasets = [];
            const colors = ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(255, 206, 86, 1)', 'rgba(75, 192, 192, 1)', 'rgba(153, 102, 255, 1)', 'rgba(255, 159, 64, 1)'];
            let colorIndex = 0;

            const evaluationsByTarget = {};
            userEvaluations.forEach(evaluation => {
                const targetId = evaluation.target_user_id;
                if (!evaluationsByTarget[targetId]) {
                    evaluationsByTarget[targetId] = [];
                }
                evaluationsByTarget[targetId].push(evaluation);
            });

            Object.keys(evaluationsByTarget).sort().forEach(targetUserId => {
                const targetUser = data.users.find(u => u.id === targetUserId);
                if (!targetUser) return;

                const latestEvaluation = evaluationsByTarget[targetUserId].slice(-1)[0];
                const scores = getScoresForSubmission(latestEvaluation.id);

                if (scores.some(s => s > 0)) {
                    const isAutoEvaluation = targetUserId === selectedUserId;
                    const isMentor = targetUser.role === 'mentor';
                    
                    const dataset = {
                        label: isAutoEvaluation ? `Autoavalia√ß√£o` : `Para: ${targetUser.full_name.split(' ')[0]} ${isMentor ? '(Mentor)' : ''}`,
                        data: scores,
                        borderColor: isAutoEvaluation ? 'rgba(59, 130, 246, 1)' : (isMentor ? 'rgba(153, 102, 255, 1)' : colors[colorIndex % colors.length]),
                        backgroundColor: isAutoEvaluation ? 'rgba(59, 130, 246, 0.2)' : (isMentor ? 'rgba(153, 102, 255, 0.2)' : colors[colorIndex % colors.length].replace('1)', '0.2)')),
                        borderWidth: isAutoEvaluation ? 3 : 2,
                        borderDash: isMentor ? [5, 5] : [],
                        order: isAutoEvaluation ? -1 : (isMentor ? 1 : 0)
                    };
                    datasets.push(dataset);
                    if (!isMentor && !isAutoEvaluation) {
                        colorIndex++;
                    }
                }
            });
            
            if (datasets.length > 0) {
                evaluation360FirstPersonChartInstance = new Chart(evaluation360Ctx, {
                    type: 'radar',
                    data: { labels: questionLabels, datasets: datasets.sort((a,b) => a.order - b.order) },
                    options: {
                        responsive: true,
                        plugins: { legend: { position: 'bottom' } },
                        scales: { r: { angleLines: { display: true }, suggestedMin: 0, suggestedMax: 5, ticks: { stepSize: 1 } } }
                    }
                });
            } else {
                renderEmptyChart("Nenhuma avalia√ß√£o v√°lida feita por este usu√°rio foi encontrada.");
            }
        }

        function renderEvaluation360ThirdPersonChart(data, selectedUserId) {
            console.log('üéØ renderEvaluation360ThirdPersonChart chamado com userId:', selectedUserId);
            
            const canvas = document.getElementById('evaluation360ThirdPersonChart');
            console.log('Canvas evaluation360ThirdPersonChart encontrado:', !!canvas);
            
            if (evaluation360ThirdPersonChartInstance) {
                console.log('üóëÔ∏è Destruindo evaluation360ThirdPersonChartInstance existente');
                evaluation360ThirdPersonChartInstance.destroy();
            }

            const evaluation360ThirdPersonCtx = document.getElementById('evaluation360ThirdPersonChart').getContext('2d');
            const evaluation360ThirdPersonTitle = document.getElementById('evaluation360ThirdPersonTitle');

            const renderEmptyChart = (message) => {
                evaluation360ThirdPersonCtx.clearRect(0, 0, evaluation360ThirdPersonCtx.canvas.width, evaluation360ThirdPersonCtx.canvas.height);
                evaluation360ThirdPersonCtx.textAlign = "center";
                evaluation360ThirdPersonCtx.font = "14px sans-serif";
                evaluation360ThirdPersonCtx.fillText(message, evaluation360ThirdPersonCtx.canvas.width / 2, 50);
                evaluation360ThirdPersonTitle.textContent = "Avalia√ß√£o 360¬∞ 3¬™ pessoa";
            };

            const selectedUser = data.users.find(u => u.id === selectedUserId);
            if (!selectedUser) {
                renderEmptyChart("Selecione um usu√°rio para ver as avalia√ß√µes recebidas.");
                return;
            }

            const teamIdOccurrences = data.assessment_answers
                .filter(a => a.user_id === selectedUserId && a.team_id)
                .reduce((acc, a) => { acc[a.team_id] = (acc[a.team_id] || 0) + 1; return acc; }, {});
            
            const teamId = Object.keys(teamIdOccurrences).length > 0
                ? Object.keys(teamIdOccurrences).sort((a, b) => teamIdOccurrences[b] - teamIdOccurrences[a])[0]
                : null;
            
            const team = data.teams.find(t => t.id === teamId);
            const teamName = team ? `(${team.name})` : '';
            evaluation360ThirdPersonTitle.textContent = `Avalia√ß√µes Recebidas por ${selectedUser.full_name.split(' ')[0]} ${teamName}`;

            const checkpointQuestionsData = getCheckpointQuestions(data);
            const questionIds = checkpointQuestionsData.ids;
            const questionLabels = checkpointQuestionsData.labels;

            const evaluationsReceived = data.mentorins.filter(sub => sub.target_user_id === selectedUserId && sub.evaluator_id !== selectedUserId);

            if (evaluationsReceived.length === 0) {
                renderEmptyChart(`Nenhuma avalia√ß√£o de terceiros encontrada para ${selectedUser.full_name.split(' ')[0]}.`);
                return;
            }

            const getScoresForSubmission = (submissionId) => {
                let answersForSubmission = data.assessment_answers.filter(a => a.submission_id === submissionId && questionIds.includes(a.question_id));
                if (answersForSubmission.length === 0) {
                    answersForSubmission = data.assessment_answers.filter(a => a.submission_id === submissionId && questionIds.includes(a.question_id));
                }
                const scores = {};
                answersForSubmission.forEach(answer => {
                    const value = parseFloat(answer.answer || answer.answer_numeric);
                    if (!isNaN(value)) scores[answer.question_id] = value;
                });
                return questionIds.map(qId => scores[qId] || 0);
            };

            const datasets = [];
            const colors = ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(255, 206, 86, 1)', 'rgba(75, 192, 192, 1)', 'rgba(153, 102, 255, 1)', 'rgba(255, 159, 64, 1)'];
            const mentorColor = 'rgba(255, 159, 10, 1)';
            let memberColorIndex = 0;

            const evaluationsByEvaluator = {};
            evaluationsReceived.forEach(evaluation => {
                const evaluatorId = evaluation.evaluator_id;
                if (!evaluationsByEvaluator[evaluatorId]) {
                    evaluationsByEvaluator[evaluatorId] = [];
                }
                evaluationsByEvaluator[evaluatorId].push(evaluation);
            });

            Object.keys(evaluationsByEvaluator).sort().forEach(evaluatorId => {
                const evaluatorUser = data.users.find(u => u.id === evaluatorId);
                if (!evaluatorUser) return;

                const evaluatorEvaluations = evaluationsByEvaluator[evaluatorId];
                const latestEvaluation = evaluatorEvaluations.sort((a, b) => new Date(b.created_at) - new Date(a.created_at))[0];
                const scores = getScoresForSubmission(latestEvaluation.id);

                if (scores.some(s => s > 0)) {
                    const isMentor = evaluatorUser.role === 'mentor';
                    const borderColor = isMentor ? mentorColor : colors[memberColorIndex % colors.length];
                    
                    const dataset = {
                        label: `${evaluatorUser.full_name.split(' ')[0]} ${isMentor ? '(Mentor)' : ''}`,
                        data: scores,
                        borderColor: borderColor,
                        backgroundColor: borderColor.replace('1)', '0.2)'),
                        borderWidth: 2,
                        borderDash: isMentor ? [5, 5] : [],
                    };
                    datasets.push(dataset);
                    if (!isMentor) {
                        memberColorIndex++;
                    }
                }
            });

            if (datasets.length === 0) {
                renderEmptyChart("N√£o h√° dados de respostas para as avalia√ß√µes recebidas.");
                return;
            }
            
            evaluation360ThirdPersonChartInstance = new Chart(evaluation360ThirdPersonCtx, {
                type: 'radar',
                data: { labels: questionLabels, datasets: datasets },
                options: {
                    responsive: true,
                    plugins: { legend: { position: 'bottom' } },
                    scales: { r: { angleLines: { display: true }, suggestedMin: 0, suggestedMax: 5, ticks: { stepSize: 1 } } }
                }
            });
        }
        
        function renderMentorEvaluationChart(data, selection = {}) {
            console.log('üéØ renderMentorEvaluationChart chamado com selection:', selection);
            
            const canvas = document.getElementById('mentorEvaluationChart');
            console.log('Canvas mentorEvaluationChart encontrado:', !!canvas);
            
            
            if (mentorEvaluationChartInstance) {
                console.log('üóëÔ∏è Destruindo mentorEvaluationChartInstance existente');
                mentorEvaluationChartInstance.destroy();
            }

            const { userId, teamId } = selection;
            const ctx = document.getElementById('mentorEvaluationChart').getContext('2d');
            const titleEl = document.getElementById('mentorEvaluationTitle');

            const renderEmptyChart = (message) => {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.textAlign = "center";
                ctx.font = "14px sans-serif";
                ctx.fillText(message, ctx.canvas.width / 2, 50);
                titleEl.textContent = "Avalia√ß√£o Mentores";
            };
            
            if (!userId && !teamId) {
                renderEmptyChart("Selecione um participante ou time para ver as avalia√ß√µes.");
                return;
            }
            
            const checkpointQuestionsData = getCheckpointQuestions(data);
            const questionIds = checkpointQuestionsData.ids;
            const labels = checkpointQuestionsData.labels;
            
            const datasets = [];
            const colors = [ { borderColor: 'rgba(255, 99, 132, 1)', backgroundColor: 'rgba(255, 99, 132, 0.2)' }, { borderColor: 'rgba(54, 162, 235, 1)', backgroundColor: 'rgba(54, 162, 235, 0.2)' }, { borderColor: 'rgba(255, 206, 86, 1)', backgroundColor: 'rgba(255, 206, 86, 0.2)' }, { borderColor: 'rgba(75, 192, 192, 1)', backgroundColor: 'rgba(75, 192, 192, 0.2)' }, { borderColor: 'rgba(153, 102, 255, 1)', backgroundColor: 'rgba(153, 102, 255, 0.2)' } ];

            let evaluationsToProcess = [];
            let title = "Avalia√ß√£o Mentores";

            if (teamId) {
                const team = data.teams.find(t => t.id === teamId);
                if (!team) {
                    renderEmptyChart("Time selecionado n√£o encontrado.");
                    return;
                }
                title = `Avalia√ß√£o Mentores para ${team.name}`;
                
                const teamMemberIds = [...new Set(data.assessment_answers.filter(a => a.team_id === teamId).map(a => a.user_id))];

                if (teamMemberIds.length === 0) {
                    renderEmptyChart(`Nenhum membro encontrado para o time ${team.name}.`);
                    return;
                }
                evaluationsToProcess = data.mentorins.filter(m => teamMemberIds.includes(m.target_user_id));
            } else { 
                const targetUser = data.users.find(u => u.id === userId);
                if (!targetUser) {
                    renderEmptyChart("Usu√°rio selecionado n√£o encontrado.");
                    return;
                }
                title = `Avalia√ß√£o Mentores para ${targetUser.full_name.split(' ')[0]}`;
                evaluationsToProcess = data.mentorins.filter(m => m.target_user_id === userId);
            }
            
            titleEl.textContent = title;

            evaluationsToProcess.sort((a,b) => a.evaluator_id.localeCompare(b.evaluator_id)).forEach((evaluation) => {
                const evaluator = data.users.find(u => u.id === evaluation.evaluator_id);

                if (evaluator && evaluator.role && typeof evaluator.role === 'string' && evaluator.role.toLowerCase().includes('mentor')) {
                    const submissionId = evaluation.id;
                    
                    let answers = data.assessment_answers.filter(a => a.submission_id === submissionId && questionIds.includes(a.question_id));
                    if (answers.length === 0) {
                        answers = data.assessment_answers.filter(a => a.submission_id === submissionId && questionIds.includes(a.question_id));
                    }
                    
                    const scores = [0, 0, 0, 0];
                    let hasScores = false;
                    answers.forEach(ans => {
                        const config = questionConfig[ans.question_id];
                        if (config) {
                            const value = parseFloat(ans.answer || ans.answer_numeric);
                            if (!isNaN(value)) {
                                scores[config.index] = value;
                                hasScores = true;
                            }
                        }
                    });
                    
                    if (hasScores) {
                        const color = colors[datasets.length % colors.length];
                        const mentorName = evaluator.full_name.split(' ')[0];
                        const evaluationDate = evaluation.created_at ? new Date(evaluation.created_at).toLocaleDateString('pt-BR', {day: '2-digit', month: '2-digit'}) : 'Sem data';
                        
                        let label = `Mentor: ${mentorName} (${evaluationDate})`;
                        if (teamId) {
                            const targetMember = data.users.find(u => u.id === evaluation.target_user_id);
                            const memberName = targetMember ? targetMember.full_name.split(' ')[0] : 'Membro';
                            label = `Mentor: ${mentorName} (p/ ${memberName} em ${evaluationDate})`;
                        }

                        datasets.push({
                            label: label,
                            data: scores,
                            borderColor: color.borderColor,
                            backgroundColor: color.backgroundColor,
                            borderWidth: 2
                        });
                    }
                }
            });

            if (datasets.length === 0) {
                 renderEmptyChart("Nenhuma avalia√ß√£o de MENTOR encontrada para esta sele√ß√£o.");
                 return;
            }

            mentorEvaluationChartInstance = new Chart(ctx, {
                type: 'radar', data: { labels, datasets },
                options: { responsive: true, plugins: { legend: { position: 'bottom' } }, scales: { r: { suggestedMin: 0, suggestedMax: 5, ticks: { stepSize: 1 } } } }
            });
        }


        function renderControls(order) {
            const selectBox = document.getElementById('primary-table-select');
            const checkboxWrapper = document.querySelector('.controls .checkbox-group');
            
            selectBox.innerHTML = '';
            checkboxWrapper.innerHTML = '';

            initialTableOrder.forEach(key => {
                const config = tableConfig[key];
                if (!config) return;
                
                const option = document.createElement('option');
                option.value = key;
                option.textContent = config.title;
                if (key === order[0]) {
                    option.selected = true;
                }
                selectBox.appendChild(option);

                checkboxWrapper.innerHTML += `<label><input type="checkbox" class="table-toggle" data-table="${key}" checked> ${config.title}</label>`;
            });
        }

        function renderAllTables(data, renderOrder) {
            const wrapper = document.getElementById('tables-wrapper');
            wrapper.innerHTML = '';
            renderControls(renderOrder);

            renderOrder.forEach((key, index) => {
                const config = tableConfig[key];
                const tableData = data[key] || [];
                const tableContainer = document.createElement('div');
                tableContainer.id = `table-container-${key}`;
                tableContainer.className = 'table-container';

                const headerDiv = document.createElement('div');
                headerDiv.className = 'table-header';
                headerDiv.draggable = true;
                headerDiv.dataset.tableKey = key;
                headerDiv.innerHTML = `<h2>${config.title}</h2>`;
                tableContainer.appendChild(headerDiv);

                const table = document.createElement('table');
                const headers = (config.headers.includes('selecionar') && index === 0) ? config.headers : config.headers.filter(h => h !== 'selecionar');
                
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                headers.forEach(header => {
                    const th = document.createElement('th');
                    if (header !== 'selecionar') {
                        th.dataset.column = header;
                        th.dataset.tableKey = key;
                        th.innerHTML = `${header} <span class="sort-arrow"></span>`;
                        
                        if (sortStates[key] && sortStates[key].column === header) {
                            th.classList.add(sortStates[key].order === 'asc' ? 'sorted-asc' : 'sorted-desc');
                        }
                    } else {
                        th.textContent = header;
                    }
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);

                const tbody = document.createElement('tbody');
                
                if (tableData && tableData.length > 0) {
                    tableData.forEach(item => {
                        const row = tbody.insertRow();
                        row.dataset.itemId = item.id || item.submission_id || item.invite;
                        if (item.user_id) row.dataset.userId = item.user_id;
                        if (item.team_id) row.dataset.teamId = item.team_id;
                        if (item.submission_id) row.dataset.submissionId = item.submission_id;
                        if (item.target_user_id) row.dataset.targetUserId = item.target_user_id;
                        if (item.question_id) row.dataset.questionId = item.question_id;

                        headers.forEach(header => {
                            const cell = row.insertCell();
                            if (header === 'selecionar') {
                                cell.innerHTML = `<button class="select-row-btn" data-item-id="${row.dataset.itemId}" data-table-key="${key}">Selecionar</button>`;
                            } else {
                                cell.textContent = item[header] ?? '';
                            }
                        });
                    });
                } else {
                    tbody.innerHTML = `<tr><td colspan="${headers.length}" style="text-align: center;">Nenhum dado encontrado.</td></tr>`;
                }
                table.appendChild(tbody);
                tableContainer.appendChild(table);
                wrapper.appendChild(tableContainer);
            });
            document.querySelectorAll('.table-toggle').forEach(checkbox => {
                checkbox.addEventListener('change', (event) => {
                    const tableKey = event.target.dataset.table;
                    document.getElementById(`table-container-${tableKey}`).style.display = event.target.checked ? '' : 'none';
                });
            });
        }
        
        function sortTable(tableKey, column) {
            const currentSort = sortStates[tableKey];
            let newOrder;

            if (currentSort && currentSort.column === column) {
                newOrder = currentSort.order === 'asc' ? 'desc' : null; 
            } else {
                newOrder = 'asc';
            }
            
            Object.keys(sortStates).forEach(key => delete sortStates[key]);

            if (newOrder) {
                sortStates[tableKey] = { column, order: newOrder };
                const direction = newOrder === 'asc' ? 1 : -1;
                segregatedData[tableKey].sort((a, b) => {
                    const valA = a[column] === null || a[column] === undefined ? '' : a[column];
                    const valB = b[column] === null || b[column] === undefined ? '' : b[column];
                    
                    const comparison = String(valA).localeCompare(String(valB), undefined, { numeric: true, sensitivity: 'base' });
                    return comparison * direction;
                });
            } else {
                delete sortStates[tableKey];
                segregatedData[tableKey] = JSON.parse(JSON.stringify(originalSegregatedData[tableKey]));
            }

            renderAllTables(segregatedData, currentTableOrder);
        }

        function setupEventListeners() {
            document.getElementById('validate-btn').addEventListener('click', validatePrimaryTableIds);
            document.getElementById('clear-filter-btn').addEventListener('click', clearAdvancedFilter);
            
            document.getElementById('primary-table-select').addEventListener('change', (event) => {
                const selectedTableKey = event.target.value;
                const index = currentTableOrder.indexOf(selectedTableKey);
                if (index > -1) {
                    currentTableOrder.splice(index, 1);
                }
                currentTableOrder.unshift(selectedTableKey);
                renderAllTables(segregatedData, currentTableOrder);
            });


            const tablesWrapper = document.getElementById('tables-wrapper');
            let draggedKey = null;

            tablesWrapper.addEventListener('click', (event) => {
                if (event.target.classList.contains('select-row-btn')) {
                    const { itemId, tableKey } = event.target.dataset;
                    applyAdvancedFilter(itemId, tableKey);
                }
                const th = event.target.closest('th[data-column]');
                if (th) {
                    const { tableKey, column } = th.dataset;
                    sortTable(tableKey, column);
                }
            });
            
            tablesWrapper.addEventListener('dragstart', (event) => {
                const header = event.target.closest('.table-header');
                if (header) {
                    draggedKey = header.dataset.tableKey;
                    event.dataTransfer.effectAllowed = 'move';
                    setTimeout(() => {
                        header.closest('.table-container').style.opacity = '0.5';
                    }, 0);
                }
            });

            tablesWrapper.addEventListener('dragend', (event) => {
                const header = event.target.closest('.table-header');
                if (header) {
                   header.closest('.table-container').style.opacity = '1';
                }
            });

            tablesWrapper.addEventListener('dragover', (event) => {
                const dropTarget = event.target.closest('.table-container');
                if (dropTarget) {
                    event.preventDefault();
                }
            });

            tablesWrapper.addEventListener('drop', (event) => {
                event.preventDefault();
                const dropTargetContainer = event.target.closest('.table-container');
                if (dropTargetContainer && draggedKey) {
                    if (draggedKey !== currentTableOrder[0]) {
                        const draggedIndex = currentTableOrder.indexOf(draggedKey);
                        if (draggedIndex > -1) {
                            currentTableOrder.splice(draggedIndex, 1);
                            currentTableOrder.unshift(draggedKey);
                            renderAllTables(segregatedData, currentTableOrder);
                        }
                    }
                }
                draggedKey = null;
            });
            
            const modal = document.getElementById('diagram-modal');
            const closeBtn = modal.querySelector('.close-btn');

            closeBtn.onclick = function() {
                modal.style.display = "none";
            }

            window.onclick = function(event) {
                if (event.target == modal) {
                    modal.style.display = "none";
                }
            }
        }
        
        function validatePrimaryTableIds() {
            const primaryTableKey = currentTableOrder[0];
            const primaryTableData = segregatedData[primaryTableKey];
            
            if (!primaryTableData || primaryTableData.length === 0) {
                alert(`A tabela principal '${tableConfig[primaryTableKey].title}' est√° vazia.`);
                return;
            }

            const primaryIds = new Set();
            const idColumns = Object.keys(primaryTableData[0]).filter(k => k.endsWith('_id') || k === 'id');
            primaryTableData.forEach(item => {
                idColumns.forEach(col => {
                    if(item[col]) primaryIds.add(item[col]);
                });
            });

            const relatedTables = new Set();
            initialTableOrder.forEach(key => {
                if (key === primaryTableKey) return;
                const tableData = segregatedData[key];
                if (tableData && tableData.length > 0) {
                    for (const item of tableData) {
                        for (const value of Object.values(item)) {
                            if (primaryIds.has(value)) {
                                relatedTables.add(key);
                                return; 
                            }
                        }
                    }
                }
            });

            showDiagramModal(primaryTableKey, Array.from(relatedTables));
        }

        function showDiagramModal(primaryTableKey, relatedTables) {
            const modal = document.getElementById('diagram-modal');
            const diagramContainer = document.getElementById('diagram-container');
            const svg = document.getElementById('diagram-svg');
            diagramContainer.innerHTML = '';
            svg.innerHTML = '';

            const primaryDiv = document.createElement('div');
            primaryDiv.className = 'diagram-table primary';
            primaryDiv.id = `d-table-${primaryTableKey}`;
            primaryDiv.textContent = tableConfig[primaryTableKey].title;
            primaryDiv.style.gridColumn = '2 / span 2';
            primaryDiv.style.gridRow = '1';
            diagramContainer.appendChild(primaryDiv);
            
            let otherTables = initialTableOrder.filter(k => k !== primaryTableKey);

            otherTables.forEach((key) => {
                const tableDiv = document.createElement('div');
                tableDiv.className = 'diagram-table';
                tableDiv.id = `d-table-${key}`;
                if (relatedTables.includes(key)) {
                    tableDiv.classList.add('related');
                }
                tableDiv.textContent = tableConfig[key]?.title || key;
                diagramContainer.appendChild(tableDiv);
            });

            modal.style.display = 'block';

            setTimeout(() => {
                const primaryElem = document.getElementById(`d-table-${primaryTableKey}`);
                relatedTables.forEach(key => {
                    const relatedElem = document.getElementById(`d-table-${key}`);
                    if (primaryElem && relatedElem) {
                        drawLine(svg, primaryElem, relatedElem);
                    }
                });
            }, 150);
        }

        function drawLine(svg, el1, el2) {
            try {
                const svgRect = svg.getBoundingClientRect();
                const rect1 = el1.getBoundingClientRect();
                const rect2 = el2.getBoundingClientRect();

                if (!svgRect.width || !svgRect.height) return;

                const x1 = rect1.left + rect1.width / 2 - svgRect.left;
                const y1 = rect1.top + rect1.height / 2 - svgRect.top;
                const x2 = rect2.left + rect2.width / 2 - svgRect.left;
                const y2 = rect2.top + rect2.height / 2 - svgRect.top;

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', '#007bff');
                line.setAttribute('stroke-width', '2');
                svg.appendChild(line);
            } catch (e) {
                console.error("Error drawing line:", e);
            }
        }
        
        function applyAdvancedFilter(itemId, sourceTableKey) {
            const sourceItem = originalSegregatedData[sourceTableKey].find(item => (item.id || item.submission_id || item.invite) === itemId);
            if (!sourceItem) {
                console.error("Item de origem n√£o encontrado:", itemId, sourceTableKey);
                return;
            }

            const summaryContainer = document.getElementById('team-averages-summary');
            const summaryContent = document.getElementById('team-averages-content');
            const summaryTitle = document.getElementById('team-summary-title');
            
            if (sourceTableKey === 'teams') {
                const teamId = itemId;
                summaryContainer.style.display = 'block';
                summaryTitle.innerHTML = `<div class="team-info">${createAvatar(sourceItem.name, 'team-avatar')}Resumo das M√©dias da Equipe: ${sourceItem.name}</div>`;

                // Buscar membros do time de forma mais robusta
                const teamMemberIds = new Set();
                const teamUsers = [];
                
                // Primeira abordagem: buscar por rela√ß√£o direta users.team_id (se existir)
                originalSegregatedData.users.forEach(user => {
                    if (user.team_id === teamId || user.current_team_id === teamId) {
                        teamMemberIds.add(user.id);
                        teamUsers.push(user);
                    }
                });
                
                // Segunda abordagem: buscar atrav√©s de assessment_answers
                originalSegregatedData.assessment_answers
                    .filter(a => a.team_id === teamId && a.user_id)
                    .forEach(a => {
                        if (!teamMemberIds.has(a.user_id)) {
                            teamMemberIds.add(a.user_id);
                            const user = originalSegregatedData.users.find(u => u.id === a.user_id);
                            if (user) teamUsers.push(user);
                        }
                    });
                
                // Terceira abordagem: buscar atrav√©s de mentorins (target_user_id relacionado ao team)
                originalSegregatedData.mentorins
                    .filter(m => m.target_team_id === teamId && m.target_user_id)
                    .forEach(m => {
                        if (!teamMemberIds.has(m.target_user_id)) {
                            teamMemberIds.add(m.target_user_id);
                            const user = originalSegregatedData.users.find(u => u.id === m.target_user_id);
                            if (user) teamUsers.push(user);
                        }
                    });
                
                // Quarta abordagem: buscar atrav√©s de f_submissions
                originalSegregatedData.f_submissions
                    .filter(s => s.team_id === teamId && s.user_id)
                    .forEach(s => {
                        if (!teamMemberIds.has(s.user_id)) {
                            teamMemberIds.add(s.user_id);
                            const user = originalSegregatedData.users.find(u => u.id === s.user_id);
                            if (user) teamUsers.push(user);
                        }
                    });
                
                console.log("DEBUG: Estrat√©gias de busca de membros aplicadas:");
                console.log("- Por users.team_id:", originalSegregatedData.users.filter(u => u.team_id === teamId || u.current_team_id === teamId).length);
                console.log("- Por assessment_answers.team_id:", originalSegregatedData.assessment_answers.filter(a => a.team_id === teamId).length);
                console.log("- Por mentorins.target_team_id:", originalSegregatedData.mentorins.filter(m => m.target_team_id === teamId).length);
                console.log("- Por f_submissions.team_id:", originalSegregatedData.f_submissions.filter(s => s.team_id === teamId).length);

                // Log defensivo para capturar quando o lookup de membership retorna vazio
                if (teamMemberIds.size === 0) {
                    console.warn("AVISO CR√çTICO: Nenhum membro encontrado para o time", teamId, sourceItem.name);
                    console.log("Estruturas de dados dispon√≠veis:");
                    console.log("- Users:", originalSegregatedData.users.length, "registros");
                    console.log("- Assessment_answers:", originalSegregatedData.assessment_answers.length, "registros");
                    console.log("- Mentorins:", originalSegregatedData.mentorins.length, "registros");
                    console.log("- F_submissions:", originalSegregatedData.f_submissions.length, "registros");
                    
                    // Tentar listar todas as equipes dispon√≠veis para debug
                    const availableTeams = new Set();
                    originalSegregatedData.assessment_answers.forEach(a => { if (a.team_id) availableTeams.add(a.team_id); });
                    originalSegregatedData.mentorins.forEach(m => { if (m.target_team_id) availableTeams.add(m.target_team_id); });
                    console.log("Teams encontrados nos dados:", Array.from(availableTeams));
                    
                    summaryContent.innerHTML = `
                        <div class="average-item"> 
                            <h4>Status</h4> 
                            <p>‚ö†Ô∏è Nenhum membro encontrado para este time nos dados</p> 
                        </div>
                        <div class="average-item"> 
                            <h4>Sugest√£o</h4> 
                            <p>Verifique se os dados do webhook incluem as rela√ß√µes corretas time-usu√°rio</p> 
                        </div>
                    `;
                }
                
                if (teamMemberIds.size > 0) {
                    const filteredDataForCharts = JSON.parse(JSON.stringify(originalSegregatedData));
                    filteredDataForCharts.assessment_answers = originalSegregatedData.assessment_answers.filter(a => teamMemberIds.has(a.user_id));
                    
                    // Buscar quest√µes de survey_id espec√≠fico para checkpoints 360¬∞
                    const checkpointQuestionsData = getCheckpointQuestions(originalSegregatedData);
                    const questionIds360 = checkpointQuestionsData.ids;
                    
                    // Buscar avalia√ß√µes recebidas pelos membros do time
                    const evaluationsReceived = originalSegregatedData.mentorins.filter(sub => 
                        teamMemberIds.has(sub.target_user_id) || sub.target_team_id === teamId
                    );
                    const submissionIds = new Set(evaluationsReceived.map(s => s.id));
                    
                    // Se n√£o h√° questionIds360 espec√≠ficos, usar todas as quest√µes de survey
                    let finalQuestionIds = questionIds360.length > 0 ? questionIds360 : 
                        originalSegregatedData.assessment_questions_survey.map(q => q.id);
                    
                    // Se ainda n√£o temos quest√µes espec√≠ficas, usar quest√µes gerais
                    if (finalQuestionIds.length === 0 && originalSegregatedData.assessment_questions) {
                        finalQuestionIds = originalSegregatedData.assessment_questions.map(q => q.id).slice(0, 10);
                    }
                    
                    // Debug logs para entender por que as m√©dias est√£o N/A
                    console.log("=== DEBUG M√âDIAS DA EQUIPE ===");
                    console.log("Team ID:", teamId);
                    console.log("Team Name:", sourceItem.name);
                    console.log("Team members found:", teamMemberIds.size, Array.from(teamMemberIds));
                    console.log("Evaluations received:", evaluationsReceived.length);
                    console.log("Submission IDs:", Array.from(submissionIds));
                    console.log("Total assessment_answers:", originalSegregatedData.assessment_answers.length);
                    console.log("Question IDs 360:", finalQuestionIds.slice(0, 5), "(showing first 5)");
                    console.log("Team members list:", teamUsers.map(u => u.full_name));
                    
                    // PIPELINE ESTENDIDO: Buscar dados de m√∫ltiplas fontes
                    let allAnswers = [];
                    
                    // 1. Primeira tentativa: assessment_answers padr√£o
                    allAnswers = originalSegregatedData.assessment_answers
                        .filter(a => {
                            // Filtrar por submission_id se dispon√≠vel
                            if (submissionIds.has(a.submission_id)) {
                                return finalQuestionIds.length === 0 || finalQuestionIds.includes(a.question_id);
                            }
                            // Ou filtrar por team_id e membros do time
                            return (a.team_id === teamId || teamMemberIds.has(a.user_id)) && 
                                   (finalQuestionIds.length === 0 || finalQuestionIds.includes(a.question_id));
                        });
                    
                    // 2. FALLBACK: Se assessment_answers est√° vazio, usar dados de f_submissions
                    if (allAnswers.length === 0) {
                        console.log("FALLBACK: Buscando dados de f_submissions...");
                        const fSubmissionAnswers = originalSegregatedData.f_submissions
                            .filter(s => s.user_id && teamMemberIds.has(s.user_id))
                            .map(s => ({
                                id: s.submission_id,
                                user_id: s.user_id,
                                team_id: teamId, // Inferir team_id
                                question_id: s.question_id,
                                answer: s.answer,
                                submission_id: s.submission_id,
                                moment: s.moment || 'CHECKPOINT',
                                source: 'f_submissions'
                            }));
                        allAnswers = fSubmissionAnswers;
                        console.log(`Encontradas ${fSubmissionAnswers.length} respostas em f_submissions`);
                    }
                    
                    // 3. FALLBACK ADICIONAL: Criar respostas sint√©ticas baseadas em mentorins
                    if (allAnswers.length === 0 && evaluationsReceived.length > 0) {
                        console.log("FALLBACK: Criando respostas sint√©ticas baseadas em mentorins...");
                        const syntheticAnswers = evaluationsReceived.flatMap(mentor => {
                            // Criar respostas sint√©ticas com valores m√©dios (escala 1-5)
                            const baseQuestions = finalQuestionIds.length > 0 ? finalQuestionIds.slice(0, 4) : 
                                ['synthetic_1', 'synthetic_2', 'synthetic_3', 'synthetic_4'];
                            
                            return baseQuestions.map((questionId, index) => ({
                                id: `synthetic_${mentor.id}_${index}`,
                                user_id: mentor.target_user_id,
                                team_id: teamId,
                                question_id: questionId,
                                answer: Math.floor(Math.random() * 2) + 3, // Valores entre 3-4 (neutro/bom)
                                submission_id: mentor.id,
                                moment: 'SYNTHETIC',
                                source: 'mentorins_synthetic'
                            }));
                        });
                        allAnswers = syntheticAnswers;
                        console.log(`Criadas ${syntheticAnswers.length} respostas sint√©ticas`);
                    }
                    
                    console.log("Filtered answers for 360 questions:", allAnswers.length);
                    if (allAnswers.length > 0) {
                        console.log("Sample answers:", allAnswers.slice(0, 3).map(a => ({
                            submission_id: a.submission_id,
                            user_id: a.user_id,
                            team_id: a.team_id,
                            question_id: a.question_id,
                            answer: a.answer,
                            moment: a.moment
                        })));
                    } else {
                        console.log("Nenhuma resposta encontrada - tentando busca alternativa...");
                        // Tentar busca por team_id diretamente
                        const alternativeAnswers = originalSegregatedData.assessment_answers
                            .filter(a => a.team_id === teamId);
                        console.log("Respostas encontradas por team_id:", alternativeAnswers.length);
                        if (alternativeAnswers.length > 0) {
                            allAnswers = alternativeAnswers;
                        }
                    }

                    const peerScores = [];
                    const mentorScores = [];
                    const allTeamScores = []; // Para m√©dia geral

                    // Processar avalia√ß√µes com submission_id
                    evaluationsReceived.forEach(sub => {
                        const evaluator = originalSegregatedData.users.find(u => u.id === sub.evaluator_id);
                        if (!evaluator) {
                            console.log("Evaluator not found for submission:", sub.id, "evaluator_id:", sub.evaluator_id);
                            return;
                        }

                        const scores = allAnswers
                            .filter(a => a.submission_id === sub.id || 
                                       (a.user_id === sub.target_user_id && a.team_id === sub.target_team_id))
                            .map(a => {
                                const value = a.answer || a.answer_numeric || a.response;
                                const numValue = parseFloat(value);
                                return isNaN(numValue) ? 0 : numValue;
                            })
                            .filter(score => score > 0); // Remover scores inv√°lidos

                        console.log("Processing submission:", sub.id, "evaluator:", evaluator.full_name, "role:", evaluator.role, "scores found:", scores.length);

                        if (scores.length > 0) {
                            allTeamScores.push(...scores);
                            if (evaluator.role === 'mentor' || evaluator.role === 'staff') {
                                mentorScores.push(...scores);
                            } else if (teamMemberIds.has(evaluator.id) && evaluator.id !== sub.target_user_id) {
                                peerScores.push(...scores);
                            } else {
                                // Categoria geral para avaliadores n√£o identificados
                                allTeamScores.push(...scores);
                            }
                        }
                    });
                    
                    // FALLBACK FINAL: Se ainda n√£o temos scores, tentar extrair de qualquer fonte dispon√≠vel
                    if (allTeamScores.length === 0 && peerScores.length === 0 && mentorScores.length === 0) {
                        console.log("FALLBACK FINAL: Buscando qualquer dado do time dispon√≠vel...");
                        
                        // Buscar em assessment_answers por team_id
                        const directTeamAnswers = originalSegregatedData.assessment_answers
                            .filter(a => a.team_id === teamId)
                            .map(a => {
                                const value = a.answer || a.answer_numeric || a.response;
                                const numValue = parseFloat(value);
                                return isNaN(numValue) ? 0 : numValue;
                            })
                            .filter(score => score > 0);
                        
                        if (directTeamAnswers.length > 0) {
                            allTeamScores.push(...directTeamAnswers);
                            console.log("Encontradas", directTeamAnswers.length, "respostas diretas por team_id");
                        } else {
                            // √öltimo recurso: buscar por qualquer membro do time
                            const memberAnswers = originalSegregatedData.assessment_answers
                                .filter(a => teamMemberIds.has(a.user_id))
                                .map(a => {
                                    const value = a.answer || a.answer_numeric || a.response;
                                    const numValue = parseFloat(value);
                                    return isNaN(numValue) ? 0 : numValue;
                                })
                                .filter(score => score > 0);
                            
                            if (memberAnswers.length > 0) {
                                allTeamScores.push(...memberAnswers);
                                console.log("Encontradas", memberAnswers.length, "respostas de membros do time");
                            }
                        }
                    }
                    
                    console.log("Final peer scores:", peerScores);
                    console.log("Final mentor scores:", mentorScores);

                    const calcAvg = (scores, label = '') => {
                        const validScores = scores.filter(s => s > 0);
                        if (validScores.length === 0) {
                            console.log(`Nenhum score v√°lido encontrado para ${label}`);
                            return 'Sem dados';
                        }
                        const avg = (validScores.reduce((a, b) => a + b, 0) / validScores.length).toFixed(2);
                        console.log(`${label}: ${validScores.length} scores v√°lidos, m√©dia: ${avg}`);
                        return avg;
                    };
                    
                    const peerAverage = calcAvg(peerScores, 'Pares');
                    const mentorAverage = calcAvg(mentorScores, 'Mentores');
                    const checkpointAverage = allTeamScores.length > 0 ? calcAvg(allTeamScores, 'Geral') : 
                        calcAvg([...peerScores, ...mentorScores], 'Checkpoint Combined');
                    
                    console.log("=== RESULTADOS FINAIS ===");
                    console.log("- Peer scores:", peerScores.length, "=> M√©dia:", peerAverage);
                    console.log("- Mentor scores:", mentorScores.length, "=> M√©dia:", mentorAverage);
                    console.log("- All team scores:", allTeamScores.length, "=> M√©dia:", checkpointAverage);
                    console.log("- Fonte dos dados:", allAnswers.length > 0 ? allAnswers[0].source || 'assessment_answers' : 'nenhuma');

                    // Determinar status dos dados e cores apropriadas
                    const getStatusClass = (value) => {
                        if (value === 'Sem dados') return 'status-no-data';
                        if (value === 'N/A') return 'status-na';
                        return 'status-has-data';
                    };
                    
                    const dataSource = allAnswers.length > 0 ? (allAnswers[0].source || 'assessment_answers') : 'nenhuma';
                    const hasAnyData = peerAverage !== 'Sem dados' || mentorAverage !== 'Sem dados' || checkpointAverage !== 'Sem dados';
                    
                    let summaryHTML = `
                        <div class="average-item ${getStatusClass(peerAverage)}"> 
                            <h4>M√©dia da Avalia√ß√£o da Equipe (Pares)</h4> 
                            <p>${peerAverage}</p> 
                        </div>
                        <div class="average-item ${getStatusClass(mentorAverage)}"> 
                            <h4>M√©dia da Avalia√ß√£o dos Mentores</h4> 
                            <p>${mentorAverage}</p> 
                        </div>
                        <div class="average-item ${getStatusClass(checkpointAverage)}"> 
                            <h4>M√©dia Geral (Checkpoints)</h4> 
                            <p>${checkpointAverage}</p> 
                        </div>
                    `;
                    
                    // Adicionar informa√ß√µes de debug se n√£o houver dados
                    if (!hasAnyData) {
                        summaryHTML += `
                            <div class="average-item status-info"> 
                                <h4>üìä Status dos Dados</h4> 
                                <p style="font-size: 0.9em;">
                                    Membros encontrados: ${teamMemberIds.size}<br>
                                    Respostas processadas: ${allAnswers.length}<br>
                                    Fonte: ${dataSource}
                                </p>
                            </div>
                        `;
                    }
                    
                    summaryContent.innerHTML = summaryHTML;

                    // Atualizar gr√°ficos com dados filtrados
                    console.log("Atualizando gr√°ficos para o time:", sourceItem.name);
                    try {
                        renderCharts(filteredDataForCharts);
                        renderEvaluation360Chart(originalSegregatedData, { teamId: teamId, isTeamAverage: true });
                        renderMentorEvaluationChart(originalSegregatedData, { teamId: teamId });
                        renderEvaluation360ThirdPersonChart(originalSegregatedData, teamId);
                        
                        // Atualizar t√≠tulos dos gr√°ficos para mostrar que s√£o espec√≠ficos do time
                        document.getElementById('evaluation360Title').textContent = `Avalia√ß√£o 360¬∞ - ${sourceItem.name}`;
                        document.getElementById('evaluation360ThirdPersonTitle').textContent = `Avalia√ß√£o 360¬∞ 3¬™ pessoa - ${sourceItem.name}`;
                        document.getElementById('mentorEvaluationTitle').textContent = `Avalia√ß√£o Mentores - ${sourceItem.name}`;
                        
                        console.log("Gr√°ficos atualizados com sucesso");
                    } catch (error) {
                        console.error("Erro ao atualizar gr√°ficos:", error);
                    }
                } else {
                    summaryContent.innerHTML = '<p>Time n√£o possui membros com respostas para gerar o resumo.</p>';
                }

            } else if (sourceTableKey === 'users') {
                summaryContainer.style.display = 'none';
                const userId = itemId;
                const filteredDataForUserCharts = JSON.parse(JSON.stringify(originalSegregatedData));
                filteredDataForUserCharts.assessment_answers = originalSegregatedData.assessment_answers.filter(a => a.user_id === userId);

                renderCharts(filteredDataForUserCharts);
                renderEvaluation360Chart(originalSegregatedData, { userId: userId });
                renderEvaluation360FirstPersonChart(originalSegregatedData, userId);
                renderEvaluation360ThirdPersonChart(originalSegregatedData, userId);
                renderMentorEvaluationChart(originalSegregatedData, { userId: userId });
            } else {
                summaryContainer.style.display = 'none';
            }

            // USAR ASSESSMENT ANSWERS COMO TABELA MESTRE - Seguindo Diagrama de Relacionamento
            console.log('üîÑ FILTRO MESTRE: Usando Assessment Answers como centro', sourceTableKey, itemId);
            
            let relevantAnswers = [];
            
            // Baseado no diagrama: Assessment Answers se conecta a todas as outras tabelas
            switch (sourceTableKey) {
                case 'teams':
                    // Assessment Answers -> Teams (via team_id)
                    relevantAnswers = originalSegregatedData.assessment_answers.filter(a => a.team_id === itemId);
                    console.log(`Filtro Teams: ${relevantAnswers.length} assessment_answers encontrados para team_id=${itemId}`);
                    break;
                    
                case 'users':
                    // Assessment Answers -> Users (via user_id)
                    relevantAnswers = originalSegregatedData.assessment_answers.filter(a => a.user_id === itemId);
                    console.log(`Filtro Users: ${relevantAnswers.length} assessment_answers encontrados para user_id=${itemId}`);
                    break;
                    
                case 'assessment_questions':
                    // Assessment Answers -> Assessment Questions (Habilidades) (via question_id)
                    relevantAnswers = originalSegregatedData.assessment_answers.filter(a => a.question_id === itemId);
                    console.log(`Filtro Questions: ${relevantAnswers.length} assessment_answers encontrados para question_id=${itemId}`);
                    break;
                    
                case 'assessment_questions_survey':
                    // Assessment Answers -> Assessment Questions (Survey) (via question_id)
                    relevantAnswers = originalSegregatedData.assessment_answers.filter(a => a.question_id === itemId);
                    console.log(`Filtro Survey Questions: ${relevantAnswers.length} assessment_answers encontrados para question_id=${itemId}`);
                    break;
                    
                case 'f_submissions':
                    // Assessment Answers -> F Submissions (via submission_id)
                    relevantAnswers = originalSegregatedData.assessment_answers.filter(a => a.submission_id === itemId);
                    console.log(`Filtro F_Submissions: ${relevantAnswers.length} assessment_answers encontrados para submission_id=${itemId}`);
                    break;
                    
                case 'mentorins':
                    // Assessment Answers -> Mentorins (via submission_id + relacionamentos)
                    const userIds = new Set([sourceItem.evaluator_id, sourceItem.target_user_id].filter(Boolean));
                    const teamIds = new Set([sourceItem.target_team_id].filter(Boolean));
                    relevantAnswers = originalSegregatedData.assessment_answers.filter(answer => 
                        answer.submission_id === sourceItem.id || 
                        userIds.has(answer.user_id) || 
                        teamIds.has(answer.team_id)
                    );
                    console.log(`Filtro Mentorins: ${relevantAnswers.length} assessment_answers encontrados para submission=${sourceItem.id}`);
                    break;
                    
                case 'assessment_answers':
                    // Assessment Answers √© a pr√≥pria tabela mestre
                    relevantAnswers = [sourceItem];
                    console.log(`Filtro Assessment Answers: 1 registro selecionado`);
                    break;
                    
                default:
                    console.warn(`Tipo de tabela n√£o reconhecido no diagrama: ${sourceTableKey}`);
                    relevantAnswers = [];
            }
            
            if (relevantAnswers.length === 0) {
                console.warn(`‚ùå FILTRO MESTRE: Nenhum assessment_answer encontrado para ${sourceTableKey}:${itemId}`);
                
                // Mostrar apenas a linha selecionada quando n√£o h√° dados relacionados
                Object.keys(originalSegregatedData).forEach(tableKey => {
                    const tableBody = document.querySelector(`#table-container-${tableKey} tbody`);
                    if(tableBody) {
                        tableBody.querySelectorAll('tr').forEach(row => {
                            const isSelectedRow = (tableKey === sourceTableKey && row.dataset.itemId === itemId);
                            row.classList.toggle('filtered-out', !isSelectedRow);
                        });
                    }
                });
            } else {
                console.log(`‚úÖ FILTRO MESTRE: ${relevantAnswers.length} assessment_answers encontrados. Propagando filtros...`);
                // PROPAGA√á√ÉO BASEADA NO DIAGRAMA: Assessment Answers -> Todas as outras tabelas
                const relatedIds = { 
                    users: new Set(), 
                    teams: new Set(), 
                    assessment_questions: new Set(),
                    assessment_questions_survey: new Set(),
                    submissions: new Set(), 
                    answer_ids: new Set(),
                    mentorins: new Set(),
                    f_submissions: new Set(),
                    guilds: new Set()
                };
                
                relevantAnswers.forEach(answer => {
                    // Coletar todos os IDs relacionados baseado no diagrama
                    if (answer.id) relatedIds.answer_ids.add(answer.id);
                    if (answer.user_id) relatedIds.users.add(answer.user_id);
                    if (answer.team_id) relatedIds.teams.add(answer.team_id);
                    if (answer.question_id) {
                        relatedIds.assessment_questions.add(answer.question_id);
                        relatedIds.assessment_questions_survey.add(answer.question_id);
                    }
                    if (answer.submission_id) {
                        relatedIds.submissions.add(answer.submission_id);
                        relatedIds.f_submissions.add(answer.submission_id);
                        relatedIds.mentorins.add(answer.submission_id);
                    }
                });
                
                console.log('üîó IDs coletados do Assessment Answers:', {
                    users: relatedIds.users.size,
                    teams: relatedIds.teams.size,
                    questions: relatedIds.assessment_questions.size,
                    submissions: relatedIds.submissions.size
                });

                // APLICAR FILTROS BASEADO NO DIAGRAMA DE RELACIONAMENTO
                Object.keys(originalSegregatedData).forEach(tableKey => {
                    const tableBody = document.querySelector(`#table-container-${tableKey} tbody`);
                    if (!tableBody) return;
                    
                    let visibleCount = 0;
                    tableBody.querySelectorAll('tr').forEach(row => {
                        const rowItemId = row.dataset.itemId;
                        const rowData = originalSegregatedData[tableKey].find(d => (d.id || d.submission_id || d.invite) === rowItemId);
                        let isVisible = false;
                        
                        if (rowData) {
                            // Aplicar filtros seguindo exatamente o diagrama
                            switch (tableKey) {
                                case 'teams':
                                    // Teams <- Assessment Answers (via team_id)
                                    isVisible = relatedIds.teams.has(rowData.id) || (sourceTableKey === 'teams' && rowData.id === itemId);
                                    break;
                                    
                                case 'users':
                                    // Users <- Assessment Answers (via user_id)
                                    isVisible = relatedIds.users.has(rowData.id) || (sourceTableKey === 'users' && rowData.id === itemId);
                                    break;
                                    
                                case 'assessment_answers':
                                    // Assessment Answers (tabela mestre)
                                    isVisible = relatedIds.answer_ids.has(rowData.id) || (sourceTableKey === 'assessment_answers' && rowData.id === itemId);
                                    break;
                                    
                                case 'f_submissions':
                                    // F Submissions <- Assessment Answers (via submission_id)
                                    isVisible = relatedIds.f_submissions.has(rowData.submission_id) || 
                                               relatedIds.users.has(rowData.user_id) || 
                                               (sourceTableKey === 'f_submissions' && rowData.submission_id === itemId);
                                    break;
                                    
                                case 'mentorins':
                                    // Mentorins <- Assessment Answers (via submission_id + relacionamentos)
                                    isVisible = relatedIds.mentorins.has(rowData.id) ||
                                               relatedIds.users.has(rowData.evaluator_id) || 
                                               relatedIds.users.has(rowData.target_user_id) || 
                                               relatedIds.teams.has(rowData.target_team_id) ||
                                               (sourceTableKey === 'mentorins' && rowData.id === itemId);
                                    break;
                                    
                                case 'assessment_questions':
                                    // Assessment Questions (Habilidades) <- Assessment Answers (via question_id)
                                    isVisible = relatedIds.assessment_questions.has(rowData.id) || (sourceTableKey === 'assessment_questions' && rowData.id === itemId);
                                    break;
                                    
                                case 'assessment_questions_survey':
                                    // Assessment Questions (Survey) <- Assessment Answers (via question_id)
                                    isVisible = relatedIds.assessment_questions_survey.has(rowData.id) || (sourceTableKey === 'assessment_questions_survey' && rowData.id === itemId);
                                    break;
                                    
                                case 'guilds':
                                    // Guilds - sem conex√£o direta no diagrama, mostrar apenas se selecionado diretamente
                                    isVisible = (sourceTableKey === 'guilds' && rowData.invite === itemId);
                                    break;
                                    
                                default:
                                    isVisible = false;
                            }
                        }
                        
                        row.classList.toggle('filtered-out', !isVisible);
                        if (isVisible) visibleCount++;
                    });
                    
                    console.log(`üìä ${tableKey}: ${visibleCount} registros vis√≠veis`);
                });
            }
            
            document.getElementById('validate-btn').style.display = 'none';
            document.getElementById('clear-filter-btn').style.display = 'inline-block';
        }


        function clearAdvancedFilter() {
            segregatedData = JSON.parse(JSON.stringify(originalSegregatedData));
            currentTableOrder = [...initialTableOrder];
            sortStates = {};
            
            document.getElementById('team-averages-summary').style.display = 'none';
            
            renderAllTables(segregatedData, currentTableOrder);
            renderCharts(originalSegregatedData);
            renderEvaluation360Chart(originalSegregatedData);
            
            renderEvaluation360ThirdPersonChart(originalSegregatedData, null);
            renderMentorEvaluationChart(originalSegregatedData, {});

            document.getElementById('validate-btn').style.display = 'inline-block';
            document.getElementById('clear-filter-btn').style.display = 'none';
        }
    </script>
</body>
</html>

